1.HTTP VS HTTPS ?

1.HTTP (HyperText Transfer Protocol)

.Not secure – data is sent in plain text
.Anyone intercepting the connection can read or modify the data
 No encryption, authentication, or data integrity
->URLs start with: http://
.Commonly used in the past or for non-sensitive internal testing
.Example risk:
Passwords, form data, or cookies can be stolen via packet sniffing.

2.HTTPS (HyperText Transfer Protocol Secure)

.Secure version of HTTP
.Uses SSL/TLS encryption
.Data is encrypted, ensuring:
.Confidentiality – data can’t be read
.Integrity – data can’t be altered
.Authentication – verifies the website’s identity
->URLs start with: https://
.Shows a padlock  in the browser
.Required for modern websites, payments, logins, and APIs


=======================================================================================================================================

2.Define web Architecture and DNS ?

1.Web Architecture

Web Architecture is the overall structure and design of a web application that defines how clients, servers, databases, and network components interact to deliver web content and services.

.Key components:
.Client – Web browser or mobile app (user interface)
.Web Server – Handles HTTP/HTTPS requests (e.g., Apache, Nginx)
.Application Server – Processes business logic
.Database – Stores and manages data
.Network/Protocols – HTTP/HTTPS, TCP/IP

.Common types:
-> Tier – Client and server together
-> Tier – Client ↔ Server
-> Tier – Client ↔ Application Server ↔ Database (most common)

2.DNS (Domain Name System)

.DNS (Domain Name System) is a naming system that translates human-readable domain names (like www.google.com) into IP addresses (like 142.250.190.14) that computers use to identify each other on the network.

Why DNS is needed:
.Humans remember names, not numbers
Computers communicate using IP addresses
How DNS works (simple):
User enters a website name in the browser
DNS server looks up the corresponding IP address
Browser connects to the web server using that IP

=========================================================================================================================================

3.Difference between ARIA and WAI ARIA ?

.ARIA vs WAI-ARIA

=>ARIA (Accessible Rich Internet Applications)

.A shortened/common name
 Informally used by developers

.Refers to accessibility attributes like:

->aria-label
->aria-hidden
->aria-role

.WAI-ARIA (Web Accessibility Initiative – ARIA)

.The official and complete name
 Defined by W3C (World Wide Web Consortium)
.Part of the Web Accessibility Initiative (WAI)
.Provides standards to make dynamic and interactive web content accessible, especially for screen readers

Key Point (Exam-Friendly)
->ARIA is the short name, while WAI-ARIA is the official specification name. 
->Both mean the same thing and serve the same purpose.
     ex.<button aria-label="Close">X</button>(html)

=========================================================================================================================================

4.How the backend of the screen works ?

=>The backend of a screen refers to what happens behind the scenes when a user interacts with a screen (web page or app UI). It includes server-side logic, databases, and APIs that process user actions and send data back to the screen.

.How the Backend of a Screen Works (Step by Step)
1.User Interaction (Frontend)

.User clicks a button, submits a form, or opens a screen
.Frontend (HTML/CSS/JS or mobile UI) captures the action

2.Request Sent to Backend

'Frontend sends a request using HTTP/HTTPS
common request types:
->GET – fetch data
->POST – send data
->PUT – update data
->DELETE – remove data
.Request goes to an API endpoint

3.Backend Processing
.Backend server (e.g., Node.js, Java, Python, PHP):
.Validates user input
.Applies business logic
.Checks authentication & authorization
.Communicates with databases or other services

4.Database Interaction
.Backend reads/writes data from/to the database
.Example: fetch user profile, save order details

5.Response Sent Back
.Backend sends a response (usually JSON)

Includes:
.Data
.Status code (200, 404, 500, etc.)

6.UI Update (Frontend)

.Frontend receives the response
.Screen updates dynamically:
.Displays data
.Shows success/error messages

=========================================================================================================================================

5.How Browser works back-end ?


.Great question! Let’s break down how a web browser works on the back-end — 
 the hidden machinery that makes your browsing experience smooth.
.Main Components of a Browser’s Back-End
 User Interface Layer

.Handles what you see: address bar, back/forward buttons, bookmarks, tabs.
.Sends your input (like typing a URL) to deeper browser processes.
.Browser Engine
.Acts as a bridge between the UI and the rendering engine.
.Decides what needs to be fetched, parsed, and displayed.

->Networking
.Manages HTTP/HTTPS requests to servers.
.Handles caching, cookies, DNS lookups, and secure connections (TLS/SSL).

->Rendering Engine
.Converts HTML, CSS, and JavaScript into the visual page you see.
  Examples: Blink (Chrome/Edge), WebKit (Safari), Gecko (Firefox).

=>Steps:

.Parse HTML → build DOM tree
.Parse CSS → build CSSOM tree
.Combine into Render Tree
.Layout → calculate positions
.Paint → draw pixels on screen

=>JavaScript Engine

.Executes scripts embedded in web pages.
.Examples: V8 (Chrome/Edge), SpiderMonkey (Firefox).
.Handles dynamic content, interactivity, and logic.

->Data Storage
.Local storage, IndexedDB, cookies, cache.
.Allows offline use and faster reloads.
.Security Sandbox
.Isolates processes so malicious code can’t easily affect your system.
.Each tab often runs in its own process for safety.

->Workflow: What Happens When You Type a URL
 You type https://example.com in the address bar.

.Browser checks cache/DNS → finds IP address.
.Networking layer sends an HTTPS request.
.Server responds with HTML, CSS, JS.
.Rendering engine parses and builds DOM + CSSOM.
.JavaScript engine runs scripts.
.Render tree → layout → paint → pixels on screen.

=========================================================================================================================================

6)Define CDN.

-> A Content Delivery Network (CDN) is a geographically distributed group of servers that work together to provide fast and secure delivery of Internet content. By caching content (such as HTML pages, JavaScript files, images, and videos) in multiple locations around the world, a CDN ensures that when a user requests data, it is served from the server physically closest to them, thereby reducing latency and improving website performance. 

=========================================================================================================================================

7)Define DNS

-> The Domain Name System (DNS) is a hierarchical and distributed naming system used to translate human-readable domain names (like google.com) into machine-readable numerical IP addresses (like 142.250.190.46). Often referred to as the "phonebook of the internet," DNS allows users to access websites using memorable names instead of complex strings of numbers.

=========================================================================================================================================

8.Explain the smallest javaScript file ?

-> What Counts as the Smallest JavaScript File?
Empty File
->A .js file with no content at all is technically valid.
.Size: 0 bytes.
.It does nothing, but browsers can load it without error.
.Minimal Valid Statement
.The smallest executable JavaScript file could contain just a semicolon (;).
.This is a no-op (no operation), but it’s syntactically valid.
.Size: 1 byte.

=========================================================================================================================================

9.How Arithemetic operators and concatenation works in browser ?

->Great topic! Let’s dive into how arithmetic operators and string concatenation work inside a browser’s JavaScript engine.
=>Arithmetic Operators in JavaScript
.Browsers use the JavaScript engine (like V8 in Chrome, SpiderMonkey in Firefox) to interpret and execute arithmetic operations.

Common operators:

(+ → Addition)
(- → Subtraction)
(* → Multiplication)
(/ → Division)
(% → Modulus (remainder))
(** → Exponentiation)

How it works:
.Parsing: The engine reads your code and builds an abstract syntax tree (AST).
.Type Conversion: If operands are numbers, it performs direct math.
.Example: 5 + 3 → 8.
.Execution: The engine uses optimized machine code to calculate results quickly.



10.JAVASCRIPT CONTROL STATEMENTS – DETAILED EXPLANATION WITH OUTPUT
===============================================================

1. SWITCH STATEMENT
------------------
Code:

let grade = "A";

switch (grade) {
  case "A": console.log("Excellent"); break;
  case "B": console.log("Good"); break;
  case "C": console.log("Average"); break;
  default: console.log("Invalid grade");
}

Explanation:
The value of variable grade is "A".
The switch statement compares this value with each case.
When it matches case "A", the statement runs and break stops further checking.

Output Explanation:
Since grade = "A" matches case "A", "Excellent" is printed.

Output:
Excellent


2.IF-ELSE STATEMENT
--------------------
Code:

let number = 5;

if (number % 2 === 0) {
  console.log("Even number");
} else {
  console.log("Odd number");
}


Explanation:
The condition checks whether the number is divisible by 2.

Output Explanation:
Number is 5, which is not divisible by 2, so the else-block executes.

Output:
Odd number


3. NESTED IF-ELSE STATEMENT
----------------------------
Code:

let marks = 85;
if(marks >= 90) {
  console.log("Grade A");
} else if(marks >= 75) {
  console.log("Grade B");
} else {
  console.log("Grade C");
}

Explanation:
Multiple conditions are checked one by one until a true condition is found.

Output Explanation:
Marks are 85. It is not >= 90, but it is >= 75, so Grade B is printed.

Output:
Grade B


4.WHILE LOOP(6 EXAMPLES)
--------------------------
Example 1

Code:

let i = 5;

while (i >= 1) {
  console.log(i);
  i--;
}


Explanation:
The loop runs as long as i is greater than or equal to 1.

Output Explanation:
i starts at 5 and decreases by 1 after each loop until it becomes 0, so values 5, 4, 3, 2, and 1 are printed.

Output:

5
4
3
2
1


Example 2:
Code:

let n = 5;
while(n > 0) {
  console.log(n);
  n--;
}

Explanation:
The loop runs while n is greater than 0.

Output Explanation:
n starts at 5 and decreases each time until it becomes 0, printing numbers from 5 to 1.

Output:
5 4 3 2 1


Example 3:
Code:

let sum = 0, x = 1;
while(x <= 5) {
  sum += x;
  x++;
}

Explanation:
The loop adds numbers from 1 to 5.

Output Explanation:
The values 1+2+3+4+5 are added to sum, resulting in 15.

Output:
15


Example 4:
Code:

let a = 2;
while(a <= 10) {
  console.log(a);
  a += 2;
}

Explanation:
The loop prints even numbers.

Output Explanation:
a starts at 2 and increases by 2 until it exceeds 10, printing even numbers.

Output:
2 4 6 8 10


Example 5:
Code:

let str = "JS";
let count = 0;
while(count < str.length) {
  console.log(str[count]);
  count++;
}

Explanation:
The loop iterates through each character of the string.

Output Explanation:
The string has two characters, so each character is printed separately.

Output:
J S


Example 6:
Code:

let num = 1;
while(num <= 1) {
  console.log("Runs once");
  num++;
}

Explanation:
The condition is true only once.

Output Explanation:
The loop executes one time and then stops because num becomes 2.

Output:
Runs once

5. DO-WHILE LOOP (6 EXAMPLES)
----------------------------

Example 1:
Code:

let i = 1;
do {
  console.log(i);
  i++;
} while(i <= 3);

Explanation:
The do-while loop executes at least once before checking the condition.

Output Explanation:
The loop prints numbers 1 to 3.

Output:
1 2 3


Example 2:
Code:

let n = 5;
do {
  console.log(n);
  n--;
} while(n > 0);

Explanation:
The loop runs until n becomes 0.

Output Explanation:
Numbers from 5 down to 1 are printed.

Output:
5 4 3 2 1


Example 3:
Code:

let x = 1, sum = 0;
do {
  sum += x;
  x++;
} while(x <= 5);

Explanation:
The loop calculates the sum of first five numbers.

Output Explanation:
1+2+3+4+5 results in 15.

Output:
15


Example 4:
Code:

let a = 2;
do {
  console.log(a);
  a += 2;
} while(a <= 10);

Explanation:
Even numbers are printed using do-while.

Output Explanation:
Even numbers from 2 to 10 are displayed.

Output:
2 4 6 8 10


Example 5:
Code:

let str = "OK";
let i2 = 0;
do {
  console.log(str[i2]);
  i2++;
} while(i2 < str.length);

Explanation:
Characters of a string are printed.

Output Explanation:
Each character of the string is printed separately.

Output:
O K


Example 6:
Code:

let num = 10;
do {
  console.log("Executes at least once");
} while(num < 5);

Explanation:
Even though the condition is false, the loop runs once.

Output Explanation:
The message is printed once because do-while executes before checking the condition.

Output:
Executes at least once


6. FOR LOOP
-----------------------------------
Code:

for(let i = 1; i <= 5; i++) {
  console.log(i);
}

Explanation:
The for loop initializes, checks condition, and increments in one line.

Output Explanation:
The loop runs from 1 to 5, printing each number.

Output:
1 2 3 4 5


10.WORKING WITH FIVE DIFFERENT SETS OF STRINGS IN JAVASCRIPT?
--------------------------------------------------------------

INTRODUCTION

In JavaScript, strings are used to store text data such as usernames, messages, and instructions shown on web pages. A string is a collection of characters enclosed in quotes. JavaScript offers many built-in properties and methods that make working with strings easy and efficient.
In this assignment, we explore five different string operations with examples, explanations, and outputs.

STRING SET 1: BASIC STRING OPERATION (CONCATENATION)
-----------------------------------------------------
Program:
let firstName = "Good";
let secondName = "Evening";
let greeting = firstName + " " + secondName;
console.log(greeting);

Explanation:
Concatenation is the process of joining strings together. The + operator is used to combine multiple strings. A space is added to separate the words properly.

Output:
Good Evening

STRING SET 2: STRING LENGTH AND LOWERCASE CONVERSION
--------------------------------------------------------
Program:
let word = "PROGRAMMING";
console.log(word.length);
console.log(word.toLowerCase());

Explanation:
The length property gives the total number of characters in a string. The toLowerCase() method converts all characters into lowercase letters. The original string is not changed.

Output:
11
programming

STRING SET 3: EXTRACTING PART OF A STRING
-------------------------------------------
Program:
let title = "Learning JavaScript";
let result = title.substring(9, 19);
console.log(result);

Explanation:
The substring() method extracts characters from a string using start and end positions. The starting index is included, and the ending index is excluded.

Output:
JavaScript

STRING SET 4: CHANGING TEXT USING REPLACE
-------------------------------------------
Program:
let text = "I study HTML";
let updatedText = text.replace("HTML", "CSS");
console.log(updatedText);

Explanation:
The replace() method replaces a specified word with another word. It modifies only the first matching value in the string.

Output:
I study CSS

STRING SET 5: CONVERTING STRING INTO ARRAY
-------------------------------------------
Program:
let items = "pen pencil eraser scale";
let list = items.split(" ");
console.log(list);

Explanation:
The split() method divides a string into an array based on a separator. Here, the string is split wherever a space occurs.

Output:
["pen", "pencil", "eraser", "scale"]

ADDITIONAL STRING OPERATIONS IN JAVASCRIPT
===========================================

CONVERTING STRING TO UPPERCASE
-------------------------------
Program:

let city = "delhi";
console.log(city.toUpperCase());

Output:
DELHI

REMOVING UNWANTED SPACES
--------------------------
Program:

let name = "   Payal   ";
console.log(name.trim());

Output:
Payal

ACCESSING A CHARACTER BY INDEX
-------------------------------
Program:

let course = "WebDevelopment";
console.log(course[3]);

Output:
D

CHECKING WORD PRESENCE IN A STRING
------------------------------------
Program:

let sentence = "JavaScript is easy";
console.log(sentence.includes("easy"));

Output:
true

CONCLUSION
-------------
JavaScript provides many useful string methods that help developers manage and modify text easily. Functions such as concatenation, substring extraction, replacing text, splitting strings, and changing letter case are essential in everyday programming. Understanding these concepts helps in writing cleaner code and improving user interaction in web applications.


11.FUNCTION PROTOTYPES IN JAVASCRIPT (FIVE SCENARIOS)?
=======================================================

INTRODUCTION

In JavaScript, functions act as objects and each function contains a special property called prototype.
The prototype is used to attach common properties and methods that can be shared by all objects created from that function.
This helps save memory because methods are not recreated for every object.
Prototype-based inheritance is a fundamental feature of JavaScript.
This assignment explains function prototypes using five different practical scenarios.

SCENARIO 1: ADDING A METHOD THROUGH PROTOTYPE
----------------------------------------------
Program:
function Student(name) {
  this.name = name;
}

Student.prototype.introduce = function () {
  return "Hi, I am " + this.name;
};

let s1 = new Student("Anita");
console.log(s1.introduce());

Explanation:
The introduce() method is added to the prototype of the Student function.
All objects created using Student can access this method.
The method is stored only once and shared by all instances.

Output:
Hi, I am Anita

SCENARIO 2: SHARING A COMMON PROPERTY USING PROTOTYPE
------------------------------------------------------
Program:
function Mobile(brand) {
  this.brand = brand;
}

Mobile.prototype.simSlots = 2;

let m1 = new Mobile("Samsung");
let m2 = new Mobile("Apple");

console.log(m1.simSlots);
console.log(m2.simSlots);

Explanation:
The simSlots property is defined in the prototype, not inside the constructor.
Both objects access the same property from the prototype, showing property sharing.

Output:
2
2

SCENARIO 3: OVERRIDING A PROTOTYPE VALUE
----------------------------------------
Program:
function Vehicle(type) {
  this.type = type;
}

Vehicle.prototype.speed = "Normal";

let bike = new Vehicle("Bike");
bike.speed = "Fast";

console.log(bike.speed);

Explanation:
The speed property is initially defined in the prototype.
When the object defines its own speed, it overrides the prototype value.

Output:
Fast

SCENARIO 4: ADDING PROTOTYPE METHOD AFTER OBJECT CREATION
----------------------------------------------------------
Program:
function Account(user) {
  this.user = user;
}

let acc1 = new Account("Payal");

Account.prototype.getStatus = function () {
  return "Account is active";
};

console.log(acc1.getStatus());

Explanation:
Even though the method is added after creating the object, it is accessible.
JavaScript checks the prototype chain while executing methods.

Output:
Account is active

SCENARIO 5: VERIFYING PROTOTYPE CONNECTION
--------------------------------------------
Program:
function Course(name) {
  this.name = name;
}

let c1 = new Course("Web Development");

console.log(Course.prototype.isPrototypeOf(c1));

Explanation:
The isPrototypeOf() method verifies whether an object exists in another object's prototype chain.

Output:
true

ADVANTAGES OF USING PROTOTYPES
------------------------------------

Saves memory by sharing methods
Prevents duplicate code
Supports inheritance
Improves execution performance
Makes programs reusable and organized

CONCLUSION
------------

Function prototypes play a vital role in JavaScript by allowing efficient sharing of properties and methods.
They help in reducing memory usage, improving performance, and implementing inheritance.
A good understanding of prototypes is necessary to build efficient and scalable JavaScript applications.


ARRAY PROGRAM USING FOR , WHILE , DO WHILE LOOP (USING FUNCTION AND WITHOUT USING FUNCTION)?s
===================================================================================

ARRAY PROGRAM USING FOR LOOP (USING FUNCTION)
-----------------------------------------------

Program 1: Print all array elements
function printArray() {
    let arr = [10, 20, 30];

    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }
}

printArray();


Steps:
Function created
Array defined
Loop prints elements

Output:
10
20
30

Program 2: Find sum of array
function sumArray() {
    let arr = [1, 2, 3, 4];
    let sum = 0;

    for (let i = 0; i < arr.length; i++) {
        sum = sum + arr[i];
    }

    console.log(sum);
}

sumArray();


Steps:
Initialize sum
Add each element
Print sum

Output:
10

Program 3: Count array elements
function countElements() {
    let arr = [5, 10, 15];
    let count = 0;

    for (let i = 0; i < arr.length; i++) {
        count++;
    }

    console.log(count);
}

countElements();


Steps:
Loop runs for each item
Count increases

Output:
3

Program 4: Print even numbers
function evenNumbers() {
    let arr = [2, 5, 8, 9, 12];

    for (let i = 0; i < arr.length; i++) {
        if (arr[i] % 2 === 0) {
            console.log(arr[i]);
        }
    }
}

evenNumbers();


Steps:
Check each number
Print even values

Output:
2
8
12


Program 5: Find largest element
function largestNumber() {
    let arr = [7, 3, 10, 5];
    let max = arr[0];

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    console.log(max);
}

largestNumber();


Steps:
Assume first element as max
Compare others
Update max

Output:
10

Program 6: Reverse array output
function reverseArray() {
    let arr = [1, 2, 3, 4];

    for (let i = arr.length - 1; i >= 0; i--) {
        console.log(arr[i]);
    }
}

reverseArray();


Steps:
Loop starts from last index
Prints backward

Output:
4
3
2
1


ARRAY PROGRAM USING WHILE LOOP (WITHOUT FUNCTION)
-------------------------------------------------

1. Print Index Numbers
let arr = [10, 20, 30];
let i = 0;

while (i < arr.length) {
  console.log(i);
  i++;
}


Steps:
Array is created.
Loop prints index.
Index increases.

Output Explanation:
Array index numbers shown.

Output:
0
1
2

2. Find First Even Number
let arr = [1, 3, 4, 6];
let i = 0;

while (i < arr.length) {
  if (arr[i] % 2 === 0) {
    console.log(arr[i]);
    break;
  }
  i++;
}


Steps:
Check each value.
Stop when even found.

Output Explanation:
First even value printed.

Output:
4

3. Print Elements Greater Than 5
let arr = [2, 6, 4, 8];
let i = 0;

while (i < arr.length) {
  if (arr[i] > 5) {
    console.log(arr[i]);
  }
  i++;
}


Steps:
Check each value.
Print greater values.

Output Explanation:
Values above 5 shown.

Output:
6
8

ARRAY PROGRAM USING WHILE LOOP (USING FUNCTION)
-------------------------------------------------

1. Print Array Elements
let arr = [3, 6, 9];
let i = 0;

while (i < arr.length) {
  console.log(arr[i]);
  i++;
}


Steps:
Start from index 0
Print each value

Output Explanation:
All elements are displayed.

Output:
3
6
9

2. Find Sum of Array
let arr = [1, 2, 3];
let sum = 0;
let i = 0;

while (i < arr.length) {
  sum = sum + arr[i];
  i++;
}

console.log(sum);


Steps:
Add each element
Print sum

Output Explanation:
Total of array values.

Output:
6

3. Print First Element
let arr = [10, 20, 30];
let i = 0;

while (i < 1) {
  console.log(arr[i]);
  i++;
}


Steps:
Loop runs once
First element printed

Output Explanation:
Only first value shown.

Output:
10

ARRAY PROGRAM USING DO while LOOP (WITHOUT FUNCTION)
----------------------------------------------------

1. Print Only First Element
let arr = [11, 22, 33];
let i = 0;

do {
  console.log(arr[i]);
  i++;
} while (i < 1);


Steps:
Array is created.
Loop runs once.
First element printed.

Output Explanation:
First value shown.

Output:
11

2. Print Only Last Element
let arr = [5, 6, 7];
let i = arr.length - 1;

do {
  console.log(arr[i]);
} while (false);


Steps:
Start at last index.
Loop executes once.
Last element printed.

Output Explanation:
Last value shown.

Output:
7

3. Count Array Elements
let arr = ["X", "Y", "Z"];
let count = 0;
let i = 0;

do {
  count++;
  i++;
} while (i < arr.length);

console.log(count);


Steps:
Loop counts each item.
Count printed.

Output Explanation:
Total elements counted.

Output:
3

ARRAY PROGRAM USING DO while LOOP (USING FUNCTION)
----------------------------------------------------

Program 1: Print all array elements
function printArray() {
    let arr = [10, 20, 30];
    let i = 0;

    do {
        console.log(arr[i]);
        i++;
    } while (i < arr.length);
}

printArray();


Steps:
Function created
Start index at 0
Print element
Increase index

Output:
10
20
30

Explanation: All array values printed.

Program 2: Find sum of array
function sumArray() {
    let arr = [1, 2, 3, 4];
    let sum = 0;
    let i = 0;

    do {
        sum = sum + arr[i];
        i++;
    } while (i < arr.length);

    console.log(sum);
}

sumArray();


Steps:
Initialize sum
Add elements
Print sum

Output:
10

Explanation: Total of numbers.

Program 3: Count array elements
function countElements() {
    let arr = [5, 10, 15];
    let count = 0;
    let i = 0;

    do {
        count++;
        i++;
    } while (i < arr.length);

    console.log(count);
}

countElements();


Steps:
Loop runs once per element
Count increases

Output:
3

Explanation: Array length is 3.








1.Explore map(),for each(), filter(),sort() reader



n 2026, JavaScript's built-in array methods like map(), forEach(), filter(), and sort() remain the standard tools for data transformation and manipulation in both front-end and back-end development. These higher-order functions allow developers to process collections without writing manual for loops, resulting in cleaner and more maintainable code. 
Essential Array Methods


map(): Creates a new array by applying a provided function to every element in the calling array. It is ideal for data transformation, such as extracting specific properties from an object or modifying values (e.g., doubling numbers).


forEach(): Executes a provided function once for each array element. Unlike map(), it does not return a value and is typically used for side effects, such as logging to the console or updating an external variable.


filter(): Creates a new array containing only the elements that pass a specific test (condition). For instance, it can be used to remove all "inactive" users from a list or select only even numbers.


sort(): Sorts the elements of an array in place and returns the sorted array. By default, it sorts elements as strings in ascending order, so a custom comparator function is often required for numbers or complex objects. 



2.Complete DOM manipulation.


n 2026, DOM (Document Object Model) manipulation remains the primary way for JavaScript to dynamically update a webpage's content, structure, and style without a full refresh. By representing the HTML document as a tree of objects (nodes), the DOM allows developers to programmatically interact with every part of a site. 


1. Selecting Elements
To modify an element, you must first find it in the DOM tree. Modern best practices favor the more flexible querySelector over older methods. 

->document.getElementById('id'): Returns the single element with the specified ID.

->document.querySelector('.class' or '#id'): Returns the first element that matches a CSS selector.

->document.querySelectorAll('.class'): Returns a static NodeList of all matching elements.

->document.getElementsByClassName('name'): Returns a live HTMLCollection of elements with that class. 



2. Modifying Content & Attributes
Once an element is selected, you can update its text, HTML, or specific attributes. 

->textContent: Updates or gets the plain text inside an element, ignoring any HTML tags.

->innerHTML: Gets or sets the HTML content inside an element. Security Tip: Use this with caution for user-provided data to avoid XSS attacks; prefer textContent for plain strings.

->setAttribute('attr', 'value'): Sets or updates an attribute like src, href, or id.

->removeAttribute('attr'): Deletes a specific attribute.




3. Styling and Classes
The most efficient way to change styles is by toggling CSS classes rather than modifying inline styles.
 
->classList.add('new-class') / remove('class'): Adds or removes a CSS class.

-.classList.toggle('active'): Adds the class if it’s missing and removes it if it exists.

->element.style.propertyName: Directly modifies inline CSS (e.g., element.style.color = 'red'). Use camelCase for properties like backgroundColor




4. Creating and Removing Elements
You can dynamically add or delete elements to change the page structure. 

->document.createElement('div'): Creates a new element node in memory.

->appendChild(newNode): Adds the new element as the last child of a parent node.

->append(...): A more modern method that can append multiple elements or strings at once.
remove(): Directly deletes the element from the DOM.

->insertBefore(newNode, existingNode): Places a new element before a specific sibling. 




5. Event Handling
Events allow the DOM to react to user interactions. 

->addEventListener('event', function): Attaches a listener (e.g., 'click', 'submit', 'keydown') to an element.

->event.preventDefault(): Prevents default browser actions, such as a form refreshing the page on submission.

->Event Delegation: A performance-best practice where you attach one listener to a parent element to handle events for all its children. 



3.Explore npm and npx


npm (Node Package Manager) and npx (Node Package Execute) remain the dual pillars of JavaScript package management, bundled with Node.js to handle distinct stages of the development lifecycle. 



1. npm: The Manager
npm is primarily a package manager used to install, update, and manage persistent dependencies for your projects. 

->Dependency Tracking: It reads and updates your package.json and package-lock.json files to ensure every developer on a team uses exact, consistent package versions.

->Persistent Storage: Packages are downloaded into your project's node_modules or global system folders permanently.

->Script Runner: Developers use npm to define and run custom workflows (e.g., npm start, npm test) via the scripts object in package.json.

->Latest in 2026: npm version 11 (standard in Node.js 24+) features smarter caching and improved dependency resolution for large-scale enterprise projects.




2. npx: The Executor
npx is a package runner designed to execute binaries on-the-fly without the need for manual, permanent installation.
 
->Zero-Install Execution: It fetches a package from the registry, runs its command, and discards the download immediately after use. This prevents "global pollution" from tools you only use once.

->Always Fresh: Unless specified otherwise, npx defaults to running the latest version of a tool, ensuring you always have current features and security patches.

->Local Binary Discovery: If a package is already installed locally, npx <command> will find it in ./node_modules/.bin and run it without requiring you to type the full file path. 









